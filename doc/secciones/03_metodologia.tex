
\chapter{Metodología}
\label{ch:metodología}
En este capítulo se describirá la forma en la que se ha trabajado durante el desarrollo del proyecto.
El marco del desarrollo será el desarrollo ágil \cite{agile-software-development}; que se centra en el usuario, por lo que se utilizará una planificación ágil, con el objetivo
de conseguir un software de calidad y flexible. Esto debe estar presente constantemente en el desarrollo del proyecto.

\section{Planificación}
\label{sc:planificación}
La planificación que se va a emplear está basada en los {\href{https://agilemanifesto.org/iso/es/principles.html}{principios del manifiesto ágil}}
Buscamos un tipo de planificación que se centre en el usuario, para que el propio usuario nos aporte retroalimentación, aunque para este caso no sea posible por la
ausencia de un cliente real, por lo que debemos de escoger una planificación específica. En mi caso he usado Kanban con la ayuda del tablero de GitHub.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\linewidth]{logos/kanban.png}
    \caption{Tablero Kanban.}
    \label{fig:layout1}
\end{figure}

Una planificación ágil nos permite adaptarnos al cambio de requisitos haciendo uso de las iteraciones y aprovechar las nuevas oportunidades que aparezcan.
El desarrollo ágil construye el sistema por medio de aportaciones frecuentes de código que aportan valor
al usuario, es necesario organizar las funcionalidades en bloques y que los cambios siempre surgen de una necesidad del usuario.

\section{Análisis de usuarios}
Dentro del marco de desarrollo ágil, comprender las necesidades y experiencias de los usuarios es fundamental para el éxito del proyecto.
En esta sección, nos adentramos en el concepto de User Journeys, una herramienta para entender cómo interactúan los usuarios con nuestro producto o servicio a lo largo de su ciclo de vida.

\input{secciones/06_user-journey.tex}

\section{Herramienta de CI/CD}
Una herramienta de integración continua y despliegue continua ayuda a un desarrollo iterativo, en el que se compruebe el trabajo constantemente; indispensable para el desarrollo ágil.
Por esta razón necesitamos una herramienta para automatizar las pruebas y la integración del código. Además, ayuda al tutor a corregir de una manera ágil e independiente, facilitando el trabajo en equipo de estudiantes y tutores.
La búsqueda de esta herramienta estará cribada por lo más estandarizado, software libre, las mejores prácticas y menos deuda técnica cause al proyecto.
Las posibles herramientas encontradas son Bitbucket, Github o Gitlab. Todas cumplen con los criterios de búsqueda, por lo que objetivamente podría ser cualquiera.
Finalmente, se ha escogido GitHub, debido a que es la más cómoda y fácil de usar para el tutor y el estudiante.
Como consecuencia de usar GitHub se "decide" escoger git, que es un sistema de control de versiones distribuido para manejar el proyecto con velocidad y eficiencia.

\section{Hitos}
\label{sec:hitos}
El desarrollo ágil debe ser incremental y para ello se debe dividir la carga de trabajo de diferentes hitos, esta carga
de trabajo corresponden a cada producto mínimamente viable (\textit{PMV}) y, a su vez, en diferentes capas de abstracción del producto.
Los hitos pueden definirse como metas a las que debemos de llegar durante el desarrollo del proyecto.
Los hitos son una buena forma de limitar los bloques de trabajo del desarrollo y su principal intención es que
al final de cada hito consigamos un producto mínimamente viable (\textit{PMV}) para que sea independiente e iterativo.
Durante el desarrollo de un hito surgen las \textit{issues}.

\subsection{Issues}
Las issues son problemas que van surgiendo durante el desarrollo del hito y
el conjunto de las soluciones de las issues de un hito deben conformar el PMV que satisfaga la necesidad del usuario.
Las issues deben hacer referencia a una historia de usuario, ya sea para solucionar un problema de la propia historia o para añadir una funcionalidad.
Todas las Issues que solucionaré durante el desarrollo para construir el sistema están descritas en GitHub. Cada issue debe tener mínimo un commit asociado a su
etiqueta y debe tener una pull request asociada para poder revisar el código.

\begin{figure}[!tb]
    \begin{center}
        \subfigure[Listado de issues.]{
            \includegraphics[width=0.9\linewidth]{logos/issues.png}
            \label{Imagen-Issues}}
        \subfigure[Listado de Pull Requests.]{
            \includegraphics[width=0.9\linewidth]{logos/pullrequest.png}
            \label{Imagen-PullRequests}}
        \label{Figura-Ciudades}
    \end{center}
\end{figure}


Los hitos que se deben de cumplir están reflejados en el GitHub y son los siguientes:

\subsection*{\href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/milestone/1}{Hito 0: Infraestructura inicial y documentación}}
\label{sb:hito0}

El primer PMV consiste en alcanzar un repositorio inicial donde comenzar a forjar toda la arquitectura del proyecto con una planificación inicial.
Para aceptar el PMV, el repositorio debe de contener:

\begin{itemize}
    \item{User Journeys.}
    \item{Hitos.}
    \item{Historias de Usuario.}
    \item{Comprobadores de gramática y ortografía.}
    \item{Comprobadores de compilación de LaTeX para la documentación.}
    \item{Documentar las secciones de Motivación, Objetivos y Planificación}
\end{itemize}

\subsection*{\href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/milestone/7}{Hito 1: Modelado del Problema con DDD}}
\label{sb:hito1}

Este PMV consiste en modular el dominio del problema para facilitar el diseño e implementación.
Para aceptar el PMV la memoria debe de recoger una sección específica sobre cómo se aplicará el DDD la cual incluya:

\begin{itemize}
    \item {Definición del dominio}
    \item {Definir el lenguaje ubicuo}
    \item {Identificar Entities, Value Objects, Aggregates}
    \item {Definir los Repositories y Services necesarios}
\end{itemize}


\subsection*{\href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/milestone/2}{Hito 2: Arquitectura básica del sistema de colas de citas - API Rest}}

Este PMV consiste en diseñar las clases y funciones necesarias para crear los turnos, priorizarla los turnos y meterlos en una cola.
A nivel de producto se ha de tener una API Rest que permita la creación de turnos y la priorización de los mismos.

\begin{itemize}
    \item {Configurar y crear los tests necesarios}
    \item {Crear los servicios necesarios para el dominio}
    \item {Crear los controladores necesarios para la API Rest}
    \item {Configurar y conectar una base de datos}
    \item {Crear los repositorios para acceder a la base de datos}
\end{itemize}

Los criterios de aceptación de este PMV son los tests de cada clase y sus funciones, además de reflejar en la memoria las decisiones tomadas

\section{Historias de Usuarios}
Este concepto es fundamental en el desarrollo ágil, ya que, resume las necesidades del usuario.
Las historias de usuario se encuentran disgregando los aspectos atómicos del \textit{user journey} que aportan valor.
Deben de definirse en el dominio del problema, por lo que están relacionadas con la lógica de negocio.
Las historias de usuario describen la necesidad del usuario abstrayéndose de los detalles técnicos, ya que
el usuario no es un experto ni en informática ni en el dominio del problema.
Encontraremos las Historias de Usuario repartidas por los Hitos del desarrollo del software.

\noindent{Se han definido las siguientes historias de usuario:}

\subsection*{\href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/issues/19}{[HU-01] Triage Inteligente - Como sanitario de urgencias quiero que el triage inteligente asigne turnos de consulta automáticamente por riesgo.}}
Como sanitario de urgencias quiero un sistema de triage inteligente que se encargue de aplicar un cribado de riesgos a los pacientes.
El triage se encarga de evaluar el estado de salud del paciente a través de un formulario dónde se le pregunta al paciente el motivo de la consulta y
síntomas que padece, con esta información el sistema le asignará un riesgo de los cinco niveles establecidos, dependiendo del riesgo el paciente tendrá una demora
específica de tiempo para ser atendido. En caso de que supere el tiempo de demora y no sea atendido se podrá revaluar el riesgo del paciente.
El triage funcionará todo el día y puede tener supervisión de un sanitario en todo momento, este sanitario podría, según su criterio cambiar el riesgo del paciente.

\subsection*{\href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/issues/101}{[HU-02] Triage Inteligente - Como sanitario de citología quiero consultar los pacientes con mayores riesgos.}}
Como sanitario de citologías quiero un sistema de triage inteligente que se encargue de aplicar un cribado de riesgos a los pacientes con mayor riesgo.
El triage inteligente en citología estará enfocado a la propia citología, por lo que se tratará de un cuestionario acerca de posibles síntomas alarmantes
que den indicios de la enfermedad. En citología, la demora de consulta es muy alta, por lo que la diagnosis precoz es fundamental para el paciente.

\subsection*{\href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/issues/5}{[HU-03] Triage Inteligente - Como sanitario de citología quiero modificar el riesgo de un paciente.}}
Como sanitario que trabaja en citología que utiliza el triage inteligente, después de una consulta con un paciente que se le haya diagnosticado de manera precoz una enfermedad grave,
quiero aumentarle el riesgo para las siguientes consultas.

\section{Control de calidad}
\label{sc:control-calidad}
Para crear un software de calidad debemos de comprobar constantemente que lo desarrollado, para ello hemos usado la integración continua.
Necesitamos pasar todos los tests antes de poder mezclar el código con la rama principal, para ello empleamos GitHub Actions.
Los tests se ejecutan automáticamente cada vez que se suben nuevos cambios. Se han definido los siguientes tests:

\begin{itemize}
    \item{Compilación de la documentación de LaTeX.}
    \item{Corrector ortográfico y gramatical.}
    \item{Análisis estático de código de Typescript - ESLint.}
\end{itemize}

\section{Metodologías de diseño de la aplicación}
Durante todo el capítulo destaca la importancia de una planificación adecuada que permita adaptarse a los cambios de forma ágil y eficiente.
La metodología que se va a utilizar en el diseño busca una estructura que permita una implementación flexible y centrada en las necesidades del usuario.

El diseño del sistema es una parte fundamental del proceso de desarrollo de software, ya que proporciona la estructura sobre la cual se construirá el sistema.
En este proyecto, se ha elegido el Diseño Dirigido por el Dominio (DDD) \cite{domain-drive-design} como enfoque principal, en línea con el desarrollo ágil debido a que ambos se centran en el usuario.
Además, DDD es buena opción cuando los desarrolladores no conocen el dominio, porque mediante la comunicación constante con los expertos de dominio se puede llegar a un entendimiento común.
De esta comunicación surgirán los términos y conceptos que se utilizarán para describir el dominio del problema que se usarán para describir el dominio del problema, también conocido como lenguaje ubicuo.

\subsection{Buenas prácticas en la modelización del dominio}
La capa de dominio es el lugar donde se encuentra modelada el dominio y lógica del negocio en diferentes clases y funciones.
En Diseño Dirigido por el Dominio solemos encontrar modelos que representan entidades, objetos de valor, agregados, repositorios y servicios, sin embargo
el desarrollo ágil es quien nos guía en la implementación de estas clases y funciones. No desarrollaremos explícitamente estos conceptos si no es estrictamente necesario, se implementarán como un modelo más.
La metodología a seguir es la de desarrollar las clases necesarias para cumplir con las historias de usuario, de esta forma se evita la sobre abstracción y se consigue un desarrollo iterativo.
Esta forma de trabajo está respaldada por los principios del software \textit{DRY}: "Don't repeat yourself", \textit{YAGNI}: "You aren't gonna need it", o \textit{AHA}: "Avoid hasty abstractions".
En resumen, estos principios nos dicen que no debemos de abstraer antes de tiempo, que no debemos de repetir código y que no debemos de hacer abstracciones innecesarias.

A pesar de lo mencionado anteriormente, debido a como se ha ido resolviendo el desarrollo  del código, se ha hecho una separación por responsabilidades en los modelos.
Separando la lógica interna del modelo con los parámetros de creación del propio modelo, para facilitar el cambio y la adaptación del modelo a las necesidades del usuario.
De esta manera cuando se agregue nuevo código, solamente se modificará esta interfaz y no la lógica ya desarrollada.
Esto es fundamental para el desarrollo ágil, ya que permite adaptarse a los cambios de manera rápida y eficiente.

Para modelar el dominio y la lógica se ha requerido conocer conceptos y datos del dominio, por lo que se ha requerido de la colaboración de expertos en el dominio.
En este caso, contaba con un experto cercano al dominio, mi hermana que es enfermera. Además, he conseguido información de expertos en este \href{https://scielo.isciii.es/scielo.php?script=sci_arttext&pid=S1137-66272010000200008}{artículo de un sistema de triage navarro}.

\subsection*{Metodología de diseño de la API}
La arquitectura de una aplicación backend puede separarse en diferentes capas de abstracción, en este caso se ha decidido separar en cuatro capas: dominio, aplicación, presentación e infraestructura.
Una vez que tenemos la capa del dominio modelada, debemos de pasar a la capa de aplicación, en la que principalmente se ejecuta la lógica de negocio. En mi código esta capa
corresponde a todos los services que se han desarrollado para el dominio. Además, esta capa va a conectar las otras 2 restantes, la capa de presentación y la capa de infraestructura.
La capa de presentación es la que recibe las peticiones externas, las controla y llama las funciones de la capa de aplicación. En mi código esta capa corresponde a los controladores de la API Rest.
La capa de infraestructura es la que se encarga de la conexión con la base de datos, en mi código esta capa corresponde a los repositorios de la base de datos.
Durante todo este proceso se ha ido asegurando la calidad del código con los tests y la integración continua. Aunque no se haya podido desarrollar test para todos los endpoints.

Inicialmente, solo iban a ser las funciones de creación, pero decidí terminar toda la API para aportar más valor a los usuarios como pide la metodología ágil.
Este es la etapa del proyecto en la que más me he separado de la metodología ágil, ya que he desarrollado más de lo necesario para cumplir con las historias de usuario.


\section{Presupuesto y recursos}

\section{Estimación de costes}


\begin{table}[H]
    \centering
    \begin{tabular}{| l | l | r |}
        \hline
        \textbf{Concepto}   & \textbf{Descripción}    & \textbf{Precio}              \\
        \hline
        Material utilizado  & Ordenador, periféricos  & Amortización de 210 €/año    \\
        Personal contratado & Ingeniero de ML Junior  & 1100-1500 €/mes (1200 €/mes) \\
        Recursos software   & Software libre gratuito & 0 €                          \\
        Recursos en la nube & GitHub plan gratuito    & 0 €                          \\
        \hline
        Coste total         & 2 meses de desarrollo   & 2.610 €                      \\
        \hline
    \end{tabular}
    \caption{Costes estimados del proyecto.}
\end{table}

Aplicamos el coeficiente máximo de amortización lineal para equipos informáticos. Este coeficiente corresponde al 25% durante 4 años.
Se incluye todo el equipo informático como conjunto operativo. Coste de compra total 870 € = 840 € ordenador, 30 € periféricos. \cite{lis}
